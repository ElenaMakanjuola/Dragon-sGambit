from operator import truediv

import pygame
import sys
import math
# Initialize Pygame
pygame.init()

# Define the screen dimensions and set up the display
WIDTH, HEIGHT = 720, 720
SQUARE_SIZE = WIDTH // 8  # 8x8 grid
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption('DND Chess')

# Define colors
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
BROWN = (139, 69, 19)
LIGHT_BROWN = (222, 184, 135)

#New colours
LIGHT_SQUARE = pygame.Color("palegreen")
DARK_SQUARE = pygame.Color("chartreuse4")

# Define piece images (you can use your own pieces as images)
# For simplicity, we'll use a placeholder text for each piece.
# For example, "R" for rook, "N" for knight, etc.

# Load piece images
##ADD TO CORRECT ONE
piece_images = {
    'K': pygame.image.load('images/black_king.png'),
    'Q': pygame.image.load('images/black_queen.png'),
    'B': pygame.image.load('images/black_bishop2.png'),
    'N': pygame.image.load('images/black_knight.png'),
    'R': pygame.image.load('images/black_rook.png'),
    'P': pygame.image.load('images/black_pawn2.png'),
    'k': pygame.image.load('images/white_king.png'),
    'q': pygame.image.load('images/white_queen.png'),
    'b': pygame.image.load('images/white_bishop2.png'),
    'n': pygame.image.load('images/white_knight.png'),
    'r': pygame.image.load('images/white_rook3.png'),
    'p': pygame.image.load('images/white_pawn2.png')
}

# Setup chess pieces in initial positions (simplified)
def setup_pieces():
    board = [
        ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
        ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
        [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
        [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
        [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
        [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
        ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
        ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
    ]
    return board

# Draw the chessboard
def draw_chessboard():
    for row in range(8):
        for col in range(8):
            color = LIGHT_SQUARE if (row + col) % 2 == 0 else DARK_SQUARE
            pygame.draw.rect(screen, color, (col * SQUARE_SIZE, row * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE))

# Draw the pieces on the board using images
def draw_pieces(board):
    for row in range(8):
        for col in range(8):
            piece = board[row][col]
            if piece != ' ':
                image = piece_images.get(piece)
                if image:
                    # Scale the image to fit the square size if needed
                    image = pygame.transform.scale(image, (SQUARE_SIZE, SQUARE_SIZE))
                    screen.blit(image, (col * SQUARE_SIZE, row * SQUARE_SIZE))







def endscreen():
    global board, selected_square, current_turn
    board = setup_pieces()
    selected_square = None
    current_turn = 'White'

    run = True
    while run:
        pygame.time.delay(1000)
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                run = False
                pygame.quit()
            #If click maybe resets game?
            if event.type == pygame.MOUSEBUTTONDOWN:
                run = False


        font = pygame.font.Font('freesansbold.ttf', 80)
        if current_turn == 'White':
            winnerTxt = font.render('Black wins! ', 1, (255,255,255))
        else:
            winnerTxt = font.render('White wins! ', 1, (255, 255, 255))

       # textRect = winnerTxt.get_rect()
        # set the center of the rectangular object.
        #textRect.center = (width // 2, height // 2)

        screen.blit(winnerTxt, (WIDTH // 2 - winnerTxt.get_width() // 2, HEIGHT - 400))
        pygame.display.update()






# Function to handle player movement
def handle_move(board, start, end):
    start_row, start_col = start
    end_row, end_col = end

    piece = board[start_row][start_col]
    # For now, we just "move" the piece by swapping the start and end positions
    if piece != '' and board[end_row][end_col].lower() != 'k':
        board[end_row][end_col] = piece
        board[start_row][start_col] = ' '
    elif board[end_row][end_col].lower() == 'k':
        board[end_row][end_col] = piece
        board[start_row][start_col] = ' '
        pygame.display.update()
        #whitres won
        endscreen()





def validate_move(board, start, end):
    start_row, start_col = start
    end_row, end_col = end
    #return True
    piece = board[start_row][start_col]
    print(piece)


    #Pawn moves - note can add en passant later
    if piece == 'p':
        #Two move start
        if start_row == 1:
            if end_row == 2 or end_row == 3:
                if start_col == end_col:
                    return True
                else:
                    return False
        #Normal one move
        elif end_col == start_col and end_row == start_row + 1:
            return True
        #capture move
        elif end_col == start_col + 1 or end_col == start_col - 1:
            if (end_row == start_row + 1 and board[end_row][end_col] != ' '
                    and not board[end_row][end_col].islower()):
                return True
            else:
                return False
        else:
            return False

    if piece == 'P':
        #Two move start
        if start_row == 6:
            if end_row == 4 or end_row == 5:
                if start_col == end_col:
                    return True
                else:
                    return False
        #normal one move
        elif end_col == start_col and end_row == start_row -1:
            return True
        #capture move
        elif end_col == start_col + 1 or end_col == start_col - 1:
            if (end_row == start_row - 1 and board[end_row][end_col] != ' '
                    and not board[end_row][end_col].isupper()):
                return True
            else:
                return False
        else:
            return True


    #Rook moves
    if piece == 'r':
        if start_row == end_row and (start_col != end_col):
            if end_col > start_col:
                #Minus one here to account for captures?
                for i in range (start_col, end_col, 1):
                    if board[start_row][i] != ' ':
                        return False
                    else:
                        return True
            if end_col < start_col:
                for i in range (start_col, -1, end_col):
                    if board[start_row][i] != ' ':
                        return False
                return True
            #Vertical move
        elif start_col == end_col:
            if start_row < end_row:
                i = start_row + 1
                while i <= end_row:
                    if board[i][end_col] != ' ':
                        return False
                return True
            if start_row > end_row:
                for i in range (start_row + 1, end_row, -1):
                    if board[i][start_col] != ' ':
                        return False
                return True

    if piece == 'k' or piece == 'K':
        #Normal moves
        if end_col == start_col:
            if end_row == start_row + 1 or end_row == start_row -1:
                if piece == 'k' and board[end_row][end_col].islower():
                    return False
                elif piece == 'K' and board[end_row][end_col].isupper() :
                    return False
                return True
            else:
                return False
        elif end_row == start_row:
            if end_col == start_col + 1 or end_col == start_col - 1:
                if piece == 'k' and board[end_row][end_col].islower():
                    return False
                elif piece == 'K' and board[end_row][end_col].isupper() :
                    return False
                return True
            else:
                return False
        elif abs(end_col - start_col) == 1 and abs(end_row - start_row) ==1:
            if piece == 'k' and board[end_row][end_col].islower():
                return False
            elif piece == 'K' and board[end_row][end_col].isupper():
                return False
            return True

    #Bishop movement
    if piece == 'b' or piece == 'B':
        dx = abs(start_row - end_row)
        dy = abs(start_col - end_col)
        if (dx == dy) and (dx > 0):
            if piece == 'b' and board[end_row][end_col].islower():
                return False
            elif piece == 'B' and board[end_row][end_col].isupper():
                return False
            else:
                #Fix this so can only move not over another piece
                 return True
    #Logic for remaining pieces not implemented yet
    if piece.lower() == "n" or piece.lower() == "q" or piece.lower == "r":
        return True

    #Queen movement





# Function to highlight the selected square
def highlight_square(board, start):
    start_row, start_col = start
    DARK_PURP = pygame.Color("darkmagenta")
    pygame.draw.rect(screen, DARK_PURP, (start_col * SQUARE_SIZE, start_row * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 5)
    ##Add functon here that showcases valid moves by highlighting/changing colour of possible square
    for row in range(8):
        for col in range(8):
            end_row = row
            end_col = col
            #Only shows valid moves for king and pawn
            if board[start_row][start_col].lower() == 'p' or board[start_row][start_col].lower() == 'k':
                if validate_move(board, (start_row, start_col), (end_row, end_col)):
                # Highlight square
                  PURP = pygame.Color("darkorchid")
                  pygame.draw.rect(screen, PURP,(col * SQUARE_SIZE, row * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 5)

    #UI/UX alo maybe try diceroll animation





# Function to check if it's the correct player's turn
def is_correct_turn(piece, current_turn):
    if current_turn == 'White' and piece.islower():  # White pieces are lowercase
        return True
    elif current_turn == 'Black' and piece.isupper():  # Black pieces are uppercase
        return True
    return False



# Main game loop
def game_loop():
    board = setup_pieces()
    selected_square = None
    current_turn = 'White'  # Start with white's turn

    while True:
        screen.fill(WHITE)
        draw_chessboard()
        draw_pieces(board)

        # Display the current turn
        font = pygame.font.SysFont(None, 36)
        turn_text = font.render(f"Turn: {current_turn}", True, (0,0, 0))
        screen.blit(turn_text, (WIDTH // 2 - turn_text.get_width() // 2, HEIGHT - 40))

        if selected_square:
            highlight_square(board, selected_square)

        # Event handling
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

            if event.type == pygame.MOUSEBUTTONDOWN:
                # Get the mouse position and map it to the board
                x, y = pygame.mouse.get_pos()
                col = x // SQUARE_SIZE
                row = y // SQUARE_SIZE

                piece = board[row][col]

                if selected_square is None:
                    # First click, select the piece
                    if piece != ' ' and is_correct_turn(piece, current_turn):
                        selected_square = (row, col)
                else:
                    # Second click, try to move the piece
                    start_row, start_col = selected_square
                    end_row, end_col = row, col

                    valid_move = validate_move(board, (start_row, start_col), (end_row, end_col))
                    if valid_move:
                        handle_move(board, (start_row, start_col), (end_row, end_col))
                        current_turn = 'Black' if current_turn == 'White' else 'White'

                    selected_square = None  # Reset selected square

        pygame.display.update()

game_loop()
